#!/usr/bin/env python3
# omitting 3 from the line above invokes Python 2.7 on Mac; this script requires 3
# also note this file should be executable on Mac and Linux

# gpsio-host.py - gpsio Python script to communicate with GPSBabel;
#  output from this wrapper script is sent over stdio to background.js

# In Linux, this file is executable and can be called directly;
#  in Windows, this file must be called from gpsio-host.bat,
#  which is registered in chrome_manifest.json and firefox_manifest.json;
#  those files are generated by the installer
#
# stdin and stdout from this code will communicate directly with
#  GPSBabel and background.js; so, to watch errors for debugging,
#  gpsio-host.py should redirect stderr only, like this for Windows:
# python "%~dp0\gpsio-host.py" %* 2> C:\gpsio-host_errors.txt

##########################################################################
# must keep this host version# hardcode the same as the extension version#
#  comment out previous version# lines here as a version history
# change descriptions are listed in popup.js
##########################################################################
# version='1.1.0' # 11-26-21 - TMG - first use of host version#
version='1.2.0' # 12-10-21 - TMG - seeveral mac bug fixes
##########################################################################

import struct
import subprocess
import sys
import json
import os
import time
import re
import configparser
import shutil

GDXML_FILENAME="Garmin/GarminDevice.xml"

# read a user-configurable options file gpsio-host.ini
#  which sets these values in the 'gpsio-host' section:
#  gpsbabel_exe - full filename of the gpsbabel executable file
#  chunk_size - integer less than 1e6; must be <1MB per Chrome spec
#  debug [optional] - True or False to enable logging file

hostdir=os.path.dirname(os.path.realpath(__file__))
iniFile=os.path.join(hostdir,'gpsio-host.ini')
if not os.path.isfile(iniFile):
    sys.exit("specified .ini file "+iniFile+" not found; aborting")

debug=False # initialize the value to make the IDE happy - override in gpsio.ini

config=configparser.ConfigParser()
config.read(iniFile)
debug=config['gpsio-host']['debug']
chunk_size=int(config['gpsio-host']['chunk_size'])
gpsbabel_exe=config['gpsio-host']['gpsbabel_exe']

def log(message):
    if debug:
        logfile.write(message+'\n')

# write debug files, if any, to cross-platform user's home directory
debug_path=os.path.expanduser("~")
if debug:
    logfile=open(os.path.join(debug_path,"gpsio-host_log.txt"),"w")
    logfile.write("GPSIO Host invoked at "+time.strftime("%a %d %b %Y %H:%M:%S")+"\n")
    logfile.write("Python="+sys.version+"\n")
    logfile.write("host version="+str(version)+"\n")
    logfile.write(".ini file="+iniFile+"\n")
    logfile.write("GPSBabel executable="+gpsbabel_exe+"\n")
    logfile.write("data transfer chunk size="+str(chunk_size)+"\n")
    logfile.write("platform="+sys.platform+"\n")
    logfile.write("arguments:"+str(sys.argv)+"\n")

win32=sys.platform=='win32'
darwin=sys.platform=='darwin'
linux=sys.platform=='linux'

if not os.path.isfile(gpsbabel_exe):
    if debug:
        logfile.write("ERROR: specified gpsbabel_exe "+gpsbabel_exe+" is not a file.  Exiting.\n")
    sys.exit()

# reopen stdout and stdin in bytes mode for all platforms
try:
    # required to avoid crazy surrogate encoding errors on mac
    # w+b causes errors on mac; wb works as excpected on windows and mac
    sys.stdout=os.fdopen(sys.stdout.fileno(),'wb')
except Exception as e:
    logfile.write('stdout reopen error:'+str(e)+'\n')
try:
    sys.stdin=os.fdopen(sys.stdin.fileno(),'rb',0)
except Exception as e:
    logfile.write('stdin reopen error:'+str(e)+'\n')

# Also, on Windows, the default I/O mode is O_TEXT. Set this to O_BINARY
# to avoid unwanted modifications of the input/output streams.

if win32:
    import msvcrt
    try:
        msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
        msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)
    except Exception as e:
        sys.exit("ABORT: "+str(e)+"\nMaybe this script is being run from the command line with no arguments?  If so, this abort is expected.  Use it from the web browser extension.")


# Helper function that sends a message to the webapp.
def send_message(message):
    # divide message in to <1MB chunks, per Chrome spec
    message=json.dumps(message)
    msglen=len(message)
    chunk_array=[message[i:i+chunk_size] for i in range(0,msglen,chunk_size)]

    if debug:
        logfile.write("msglen="+type(msglen).__name__+":"+str(msglen)+"\n")
        logfile.write("message="+type(message).__name__+":"+str(message)+"\n")
        logfile.write("chunk_array length: "+str(len(chunk_array))+"\n")

    # send each chunk as a separate message; each is UTF-8 encoded JSON,
    #  prepended by 32-bit length of encoded message, per Chrome spec
    for chunk in chunk_array:
        json_chunk=json.dumps(chunk)
        json_chunklen=len(json_chunk)
        json_chunklen_bytes=struct.pack('@I',json_chunklen)
        if debug:
            logfile.write("CHUNK:"+chunk+"\n")
            logfile.write(" JSON:"+json_chunk+"\n")
        z=sys.stdout.write(json_chunklen_bytes)
        try: # flush is not strictly necessary but will fail if the pipe was broken for any reason
            sys.stdout.flush()
        except Exception as e:
            log('ERR:'+str(e))
        z=sys.stdout.write(json_chunk.encode('latin-1'))
        try: # flush is not strictly necessary but will fail if the pipe was broken for any reason
            sys.stdout.flush()
        except Exception as e:
            log('ERR:'+str(e))


def Main():
    # process the 32-bit message length to determine how many bytes to read
    request_length_bytes = sys.stdin.read(4)

    try:
        request_length = struct.unpack('i', request_length_bytes)[0]
    except Exception as e:
        logfile.write("Error during initial read from stdin: "+str(e))

    if debug:
        logfile.write("request_length="+type(request_length).__name__+":"+str(request_length)+"\n")

    # read the request of specified length: UTF-8 encoded JSON, per Chrome specs
    request = sys.stdin.read(request_length).decode('utf-8')

    if debug:
        logfile.write("request="+type(request).__name__+":"+str(request)+"\n")


    # validate and parse the request
    rq = json.loads(request)

    # get the filter options, if they exist
    options={}
    if "options" in rq:
        options=rq["options"]

    removeNumberFromAssignmentNames=True # default value
    if 'removeNumbers' in options:
        removeNumberFromAssignmentNames=options['removeNumbers'] # use value from options, if specified

    if "cmd" in rq:
        cmd=rq["cmd"]
        data=None
        if cmd=="export":
            if "data" in rq:
                data=rq["data"]
                if removeNumberFromAssignmentNames:
                    # Since assignment boundary tracks are indistinguishable from non-assignment
                    #  tracks in GPX, we should make this as specific as possible:
                    # 
                    # If the name has two 'words' (groups of non-space characters separated by a space)
                    #  then remove the space and the second word only if the second word is a number.
                    #  
                    # (e.g. we want to change 'AA 101' to 'AA', but we want to preserve 'My track')

                    #  PITFALLS of this method:
                    #  - This represents a difference in generated output between Export-GPSIO and Export-GPX.
                    #      So, if one GPS device is written using Export-GPSIO, but another GPS device
                    #      is written using Export-GPX, they will see different track names in the field,
                    #      and the goal of reducing confusion will be negated.
                    #  - There could still be unintentionally modified names, e.g. 'Track 3' would be changed to 'Track'.
                    #  - This would not work if the second word contains letters (e.g. team 103b)
                    #
                    # As of 10-5-21, non-assignment tracks (lines) have a GPX extension to specify
                    #  the track color, but this could change at any time, so may not be a reliable
                    #  filter criteria, and it would take more complex parsing to identify:
                    #  <trk><name>joe</name><extensions><gpxx:TrackExtension><gpxx:DisplayColor>Red
                    #    </gpxx:DisplayColor></gpxx:TrackExtension></extensions><trkseg>...
                    
                    pattern=r'<trk><name>([^ ]*) [0-9]*</name>'
                    repl=r'<trk><name>\1</name>'
                    data=re.sub(pattern,repl,data)

            else:
                send_message({'cmd': 'export', 'status': 'error', 'message': 'when \'cmd\' is \'export\', \'data\' must be specified in the JSON request'})
                sys.exit()
    else:
        send_message({'cmd': 'NONE', 'status': 'error', 'message': 'must specify \'cmd\' in the JSON request'})
        sys.exit()

    if cmd == "ping-host":
        send_message({'cmd': 'ping-host', 'status': 'ok', 'version': version})
        sys.exit()

    # differentiate by GPS brand and protocol
    if "target" in rq:
        target=rq["target"]

        if target=="garmin":
            # Garmin procedure:
            # 1. scan for a Garmin Mass Storage Mode device, which would appear as
            #     a drive with a file <drive>:/Garmin/GarminDevice.xml
            # 2a. if GMSM device is found: for import, recursively read all .gpx
            #      files under Garmin/XML; for export, just write the .gpx there
            # 2b. if no GMSM device is found, try Garmin Mode using gpsbabel
            # 2c. if still no connection, return with an error
            drive=scan_for_gmsm()
            if drive:
                if debug:
                    logfile.write("GMSM drive found at "+drive+"; calling transfer_gmsm\n")
                transfer_gmsm(cmd,data,drive,options)
            else:
                if debug:
                    logfile.write("No GMSM drive was found; calling transfer_gbsbabel\n")
                transfer_gpsbabel(cmd,data,"garmin")
        else:
            send_message({'cmd': cmd, 'status': 'error', 'message': 'Currently, \'garmin\' is the only supported target'})
            sys.exit()
    else:
        send_message({'cmd': cmd, 'status': 'error', 'message': 'must specify \'target\' in the JSON request'})
        sys.exit()

    if debug:
        logfile.write("rq.cmd:"+cmd+"\n")
        logfile.write("rq.target:"+target+"\n")

# ensure_xmlns: if needed, add namespace definitions like 'xmlns:gpxtrkx...'
# mmap is nice because it modifies the file in place rather than
#  needing to make a new temp file, but, it isn't truly portable
#  (mmap.resize doesn't exist on mac) and gpsio better already have
#  permission to write files, so, do it using 'standard' python read and write
def ensure_xmlns(filename,name,text):
    logfile.write("Checking "+filename+" for 'xmlns:"+name+"' ... ")
    found=False
    with open(filename,mode='r+',encoding='utf-8') as f:
        for line in f:
            if 'xmlns:'+name in line:
                found=True
                break
    if found:
        logfile.write('found.\n')
    else:
        logfile.write('not found.  Adding...\n')
    
    if not found:
        tmpname=filename+'.tmp'
        with open(tmpname,'w') as outfile:
            with open(filename,mode='r+',encoding='utf-8') as infile:
                for line in infile:
                    if '<gpx' in line:
                        i=0
                        pad1=''
                        pad2=' '
                        try:
                            i=line.index('xmlns:')
                        except:
                            try:
                                i=line.index('creator')
                            except:
                                try:
                                    i=line.index('version')
                                except:
                                    i=line.index('>')
                                    pad1=' '
                                    pad2=''
                        if i>0:
                            outline=line[:i]+pad1+text+pad2+line[i:]
                    else:
                        outline=line
                    outfile.write(outline)
        os.replace(tmpname,filename)

# step 1: find the connected device (i.e. the connected drive)
#  return value: full filename of the first <drive>:\Garmin\GarminDevice.xml
#     file that was found, or False if none was found, indicating no Garmin
#     Mass Storage Mode device is connected
def scan_for_gmsm():
    if win32:
        drives=["A:\\","B:\\","C:\\","D:\\","E:\\","F:\\","G:\\","H:\\","I:\\","J:\\","K:\\","L:\\","M:\\","N:\\"]
        for drive in drives:
            if os.path.exists(os.path.join(drive, GDXML_FILENAME)):
                return drive
        return False
    elif darwin:
        vols = os.listdir('/Volumes')
        for vol in vols:
            if debug:
                logfile.write('Checking for '+os.path.join('/Volumes', vol, GDXML_FILENAME) + "\n")
            if os.path.exists(os.path.join('/Volumes', vol, GDXML_FILENAME)):
                return os.path.join('/Volumes', vol)
    else:
        return False

def transfer_gmsm(cmd,data,drive,options):
        # Apparently, the file structure on a GPSmap 62s looks like this:
        # 1. the file specified by parsing GarminDevice.xml (apparently always
        #     Garmin/GPX/Current/Current.gpx) only contains the current track log if
        #     there is one.  Waypoints, saved tracks, and routes do not appear in
        #     this file.
        # 2. Saved route: Garmin/GPX/Route_yyyy-mm-dd<space>hhmmss.gpx
        # 3. Saved track: Garmin/GPX/Track_<track_name>.gpx
        # 4. Saved waypoints: Garmin/GPX/Waypoints_dd-MMM-yy.gpx
        # 5. Archived track: Garmin/GPX/Archive/<track_name>.gpx
        #
        # Apparently, the safest method to import from the GPS is to just recursively
        #  read all gpx files in Garmin/GPX.
        #
        # When a file is copied to this directory from the computer, apparently the
        #  file remains until all objects in it have been deleted.  Needs to be verified.

        # If some objects from that file are deleted using the GPS, the same file will
        #  be re-saved without the deleted objects.  Needs to be verified.
        #
        # So, when saving a file to Garmin/GPX from the computer, it should not begin
        #  with Route_ or Track_ or Waypoints_.

        # notes:
        # - export from GCP creates Garmin/GPX/temp.GPX
        # - create waypoints, track, and route on gps; import them using GCP; add
        #    a waypoint,route,track in caltopo; export all to gps; then read again,
        #    without unplugging the gps, and everything IS listed twice!  So, it is
        #    reading temp.GPX in addition to all the other gpx files.
        #   then cancel GCP without reading; unplug, re-plug and look at the files:
        #    new file Imported_yyyy-mm-dd<space>hhmmss.gpx exists in Garmin/GPX and
        #    it has everything (but not duplicates).  Maybe just a renamed version
        #    of temp.GPX?  (temp.GPX no longer exists)
        #   now try to import using GCP, and duplicates still exist - indication that
        #    it is still reading all .gpx files.
        #   unplug and delete one of the items that were created in and exported from
        #    caltopo; then plug back in and view files: the same Imported_ file
        #    (and same id) exists, but the deleted object(s) have been deleted from
        #    that file.
        #   unplug and delete all of the items that were exported from caltopo; then
        #    re-plug: that Imported_ file no longer exists.

    if debug:
        logfile.write("inside transfer_gmsm\n")

    if cmd=="import":

        # 1. get a list of .gpx files to import
        # start with a list of all .gpx files recursively under Garmin/GPX
        gpx_files=[]
        gpxdir=os.path.join(drive,'Garmin','GPX')
        if debug:
            logfile.write("Checking recursively for .gpx files, starting at "+gpxdir+"\n")
        if darwin:
            import glob
            gpxlocaldir='/tmp/gpsio-gpxtmp'
            shutil.rmtree(gpxlocaldir,ignore_errors=True)

            # build the osa script file from the template
            with open(os.path.join(hostdir,'gpsio-osa1_template.txt'),'r') as f:
                fdata=f.read()
            fdata=fdata.replace('SCRIPTFILE',os.path.join(hostdir,'gpsio-host-macfile.py'))
            fdata=fdata.replace('GPXDIR',gpxdir)
            fdata=fdata.replace('TARGETDIR',gpxlocaldir)
            fdata=fdata.replace('OPTIONS',json.dumps(options).replace('"','\\"'))
            with open('/tmp/gpsio-osa1.txt','w') as f:
                f.write(fdata)

            subprocess.run(['osascript','/tmp/gpsio-osa1.txt'],stdin=subprocess.DEVNULL,stdout=subprocess.DEVNULL)

            # subprocess waits for command completion, but in this case osascript is complete
            # before gpsio-host-macfile.py is complete, and before the temp dir is populated;
            # so, wait here in python until the json file exists,
            # which indicates the directory has been full populated.  Do this in two stages: the directory
            # should be created almost immediately, but the file transfers could take a while; timeout after 20 seconds.
            totalSleep=0
            slp=0.1
            while not os.path.isdir(gpxlocaldir) and totalSleep<2:
                time.sleep(slp)
                totalSleep+=slp
            if not os.path.isdir(gpxlocaldir):
                log('Unexcpected timeout: GPX local directory was never created.')
                send_message({'cmd': cmd, 'status': 'error', 'message': 'Unexcpected timeout: GPX local directory was never created.' })
                sys.exit()

            totalSleep=0
            while not os.path.isfile(gpxlocaldir+'/gpxfiles.json') and totalSleep<20:
                time.sleep(slp)
                totalSleep+=slp
            if not os.path.isfile(gpxlocaldir+'/gpxfiles.json'):
                log('Unexcpected timeout: GPX index file was never created.')
                send_message({'cmd': cmd, 'status': 'error', 'message': 'Unexcpected timeout: GPX index file was never created.' })
                sys.exit()

            os.remove('/tmp/gpsio-osa1.txt')

            # close the window spawned by the first osascript call above
            subprocess.run(['osascript',hostdir+'/gpsio-osa2.txt'],stdin=subprocess.DEVNULL,stdout=subprocess.DEVNULL)

            gpx_files=[os.path.join(gpxlocaldir,f) for f in glob.glob(gpxlocaldir+'/*.[Gg][Pp][Xx]')]
            log('final gpx_files:\n'+str(gpx_files))
            gj={}
            try:
                with open(gpxlocaldir+'/gpxfiles.json') as gjf:
                    gj=json.load(gjf)
            except Exception as e:
                log(str(e))
            totalFileCount=len(gj.keys())
        else:
            for root, dirs, files in os.walk(gpxdir):
                for file in files:
                    if file.upper().endswith(".GPX") and not(file.startswith(".")):
                        fullpath=os.path.join(root,file)
                        gpx_files.append(fullpath)

            # reverse chronological sort (most recent file is first in the list)
            gpx_files=sorted(gpx_files,key=os.path.getmtime,reverse=True)
            totalFileCount=len(gpx_files)
            
            if totalFileCount == 0:
                if debug:
                    logfile.write("No GPX files were found on the device.\n")
                send_message({'cmd': cmd, 'status': 'error', 'message': 'No GPX files were found on the device.' })
                sys.exit()

            # apply file filtering as specified in the extension options
            if "method" in options:
                if options["method"]=="recent" and "recentSel" in options:
                    # only get files m thru n (both are one-based) from the sorted list
                    #  (set m=1 by default; not currently specified in the options;
                    #    leave it here for forward compatibility using 'recentSelFirst')
                    m=1
                    if "recentSelFirst" in options:
                        m=int(options["recentSelFirst"])
                    n=int(options["recentSel"])

                    # make sure 1<=n<=totalFileCount
                    n=max(1,min(n,totalFileCount))
                    # then make sure 1<=m<=n
                    m=max(1,min(m,n))
                    
                    if debug:
                        logfile.write("Selecting files "+str(m)+" thru "+str(n)+" from a reverse-chronological-order sorted list...\n")
                    gpx_files=gpx_files[m-1:n]
                    
                if options["method"]=="time" and "timeSel" in options:
                    currentTime=time.time()
                    if debug:
                        logfile.write("Filtering out files older than "+options["timeSel"]+" hours...\n")
                    gpx_files=[f for f in gpx_files if (currentTime-os.path.getmtime(f))/3600<int(options["timeSel"])]    

            if "size" in options:                
                if options["size"]==True and "sizeSel" in options:
                    if debug:
                        logfile.write("Filtering out files larger than "+options["sizeSel"]+"...\n")
                    # as long as sizeSel is in the format of <n>kb or <n>mb (case does not matter)
                    #  then the following line will filter correctly, i.e. '10kB' or '5MB'
                    gpx_files=[f for f in gpx_files if (os.path.getsize(f)<eval(options["sizeSel"].lower().replace("kb","*1024").replace("mb","*1048576")))]

        # end of platform-dependent scan-and-filter(-and-copy for mac)
        
        for f in gpx_files:
            ensure_xmlns(f,'gpxtrkx','xmlns:gpxtrkx="http://www.garmin.com/xmlschemas/TrackStatsExtension/v1"')
            ensure_xmlns(f,'gpxx','xmlns:gpxx="http://www.garmin.com/xmlschemas/GpxExtensions/v3"')

        # list the filtered file set
        filteredFileCount=len(gpx_files)
        if filteredFileCount == 0:
            if debug:
                logfile.write("No recent files out of " + str(totalFileCount) + " total gpx files on the device:\n")
            send_message({'cmd': cmd, 'status': 'error', 'message': 'No GPX files out of '+str(totalFileCount)+' met the filter settings.  Click the GPSIO Extension icon for details.' })
            sys.exit()
        if debug:
            logfile.write("Sending "+str(filteredFileCount)+" out of "+str(totalFileCount)+" total gpx files on the device:\n")
            logfile.write(str(gpx_files)+"\n")
        
        # 2. use gpsbabel to combine the files and send to the extension
        args=[gpsbabel_exe,"-w","-r","-t","-i","gpx"]
        for gpx_file in gpx_files:
            args.extend(("-f",gpx_file))
        args.extend(("-o","gpx","-F","-"))
        if debug:
            logfile.write("invoking: "+str(args)+"\n")
            logfile.write("with data: "+str(data)+"\n")
        p=subprocess.Popen(args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        output, err = p.communicate(data)
        if err != None and len(err) > 2:
            send_message({'cmd': cmd, 'status': 'error', 'message': str(err.decode('latin-1')) })
        else:
            if err!=b'' and debug:
                logfile.write("err: "+str(err)+"\n")
            note="Showing data from "+str(filteredFileCount)+" out of "+str(totalFileCount)+" total GPX file(s).  Click the GPSIO Extension icon for details."
            send_message({'cmd': cmd, 'status': 'ok', 'note': note, 'message': str(output.decode('latin-1')) })
    elif cmd=="export":
        gpx_dir=os.path.join(drive,'Garmin','GPX')
        if not os.path.exists(gpx_dir):
            send_message({'cmd': cmd, 'status': 'error', 'message': 'GPS located at '+str(drive)+': but Garmin/GPX directory was not found'})
            sys.exit()
        gpx_fname=os.path.join(drive,'Garmin','GPX','gpsio'+time.strftime("%Y_%m_%d_%H%M%S")+'.gpx')
        if debug:
            logfile.write("gpx_fname="+str(gpx_fname)+'\n')
        gpx=open(gpx_fname,"w")
        gpx.write(data)
        gpx.close
        send_message({'cmd': cmd, 'status': 'ok', 'message': "GMSM export successful"})
    else:
        send_message({'cmd': cmd, 'status': 'error', 'message': 'cmd must be \'import\' or \'export\''})
        sys.exit()

def transfer_gpsbabel(cmd,data,target):
    # build the subprocess command
    if(cmd=="import"):
        args=[gpsbabel_exe,"-w","-r","-t","-i",target,"-f","usb:","-o","gpx","-F","-"]
    elif(cmd=="export"):
        args=[gpsbabel_exe,"-w","-r","-t","-i","gpx","-f","-","-o",target,"-F","usb:"]
        data=data.encode('utf-8')
        if debug:
            logfile.write("rq.data length:"+str(len(data))+"\n")
            logfile.write("rq.data:"+str(data)+"\n")
    else:
        send_message({'cmd': cmd, 'status': 'error', 'message': 'cmd must be \'import\' or \'export\''})
        sys.exit()

    # do the subprocess command and send any data
    if debug:
        logfile.write("invoking: "+str(args)+"\n")
    p=subprocess.Popen(args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if debug:
        logfile.write("  subprocess object created... ")
    output, err = p.communicate(data)
    if debug:
        logfile.write("  subprocess communcation complete.\n")

    # if no usb device is found, err will be a multi-line string like this:

    # for GPSBabel 1.5.3 on Vista:

        #[ERROR] SetupDiEnumDeviceInterfaces: The system cannot find the path specified.
        #Is the Garmin USB unit number 0 powered up and connected?
        #Is it really a USB unit?  If it's serial, don't choose USB, choose serial.
        #Are the Garmin USB drivers installed and functioning with other programs?
        #Is it a storage based device like Nuvi, CO, or OR?
        #  If so, send GPX files to it, don't use this module.
        #[ERROR] Get_Time: Unknown date/time protocol
        #GARMIN:Can't init usb:

    # for GPSBabel 1.5.3 on Windows 7: all the same as above, except the first line:

        #[ERROR] SetupDiEnumDeviceInterfaces: The device is not ready.

    if err:
        err=str(err.decode('latin-1'))
        if debug:
            logfile.write("err: "+err)
        if "The system cannot find the path specified." in err or "The device is not ready." in err:
            send_message({'cmd': cmd, 'status':'error','message':'no GPS was found'})
        else:
            send_message({'cmd': cmd, 'status':'error','message':err})
        sys.exit()

    if debug:
        response = {}
        response['output']=str(output.decode('latin-1'))
        logfile.write("resonse: " + json.dumps(response))
        logfile.write("output="+type(output).__name__+":"+str(output)+"\n")
        logfile.write("Total xml response length: "+str(len(output))+" bytes\n")

    if(cmd=="import"):
        send_message({'cmd': cmd, 'status': 'ok', 'message': str(output.decode('latin-1'))})
    elif(cmd=="export"):
        send_message({'cmd': cmd, 'status': 'ok', 'message': "GPSBabel export successful"})


if __name__ == '__main__':
    Main()
